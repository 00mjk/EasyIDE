(* ::Package:: *)

(* Autogenerated Package *)

WithNotebookPaused::usage="Pauses the notebook temporarily to execute code";
PreemptiveQueued::usage="Evaluates preemptive code in a queued fashion";


WithCurrentValueUpdating::usage="Executes with CurrentValue updating resumed";
WithoutCurrentValueUpdating::usage="Executes with CurrentValue updating paused";


(* ::Text:: *)
(*Consistent references to the current IDE notebook*)



$CurrentIDENotebook::usage="";
$CurrentIDE::usage="";


SetCurrentValue::usage="";
SetCurrentValueDelayed::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*CurrentValues*)



SetCurrentValue//Clear
SetCurrentValue[nb_, k_, value_]:=
  With[{h=FrontEnd`$TrackingEnabled},
    MathLink`CallFrontEndHeld[
      FrontEnd`SetValue[
          FEPrivate`Set[
            FrontEnd`CurrentValue[nb, k], 
          value
            ],
          h
          ]
      ]
    ]


SetCurrentValueDelayed//Clear
SetCurrentValueDelayed[nb_, k_, Hold[value_]]:=
  With[{h=FrontEnd`$TrackingEnabled},
    MathLink`CallFrontEndHeld[
      FrontEnd`SetValue[
        FEPrivate`SetDelayed[
          FrontEnd`CurrentValue[nb, k], 
          value
          ],
        h
        ]
      ]
    ]


(* ::Subsection:: *)
(*IDE Refs*)



$CurrentIDENotebook := EvaluationNotebook[];
$CurrentIDE := IDENotebookObject[$CurrentIDENotebook];


(* ::Subsection:: *)
(*Helpers*)



(* ::Subsubsection::Closed:: *)
(*WithPausedNotebook*)



(* ::Text:: *)
(*
	Helper function to suspend the screen while updating the nb
*)



WithNotebookPaused[nb_NotebookObject, expr_]:=
  Block[
  {
    paused = If[TrueQ@paused, True, False],
    FrontEnd`$TrackingEnabled = False,
    setDataCalls 
      (* 
	            Should I catch all of the ideSetNbData calls...? 
	            I could batch them all up at once and maybe decrease the amount of processing time...
	            *)
    },
    If[paused,
      expr,
      Internal`WithLocalSettings[
        FrontEndExecute@
          FrontEnd`NotebookSuspendScreenUpdates[nb];,
        paused = True;
        expr,
        FrontEndExecute@
          FrontEnd`NotebookResumeScreenUpdates[nb];
        ]
      ]
    ];
WithNotebookPaused~SetAttributes~HoldRest


(* ::Subsubsection::Closed:: *)
(*WithCurrentValueUpdating*)



WithCurrentValueUpdating[expr_]:=
  Block[
  {
    FrontEnd`$TrackingEnabled = True
    },
    expr
    ];
WithCurrentValueUpdating~SetAttributes~HoldRest


(* ::Subsubsection::Closed:: *)
(*WithoutCurrentValueUpdating*)



(* ::Text:: *)
(*
	Helper function to suspend the screen while updating the nb
*)



WithCurrentValueUpdating[expr_]:=
  Block[
  {
    FrontEnd`$TrackingEnabled = False
    },
    expr
    ];
WithCurrentValueUpdating~SetAttributes~HoldRest


(* ::Subsubsection::Closed:: *)
(*IDEPreemptive*)



PreemptiveQueued[nb_, expr_]:=
  MessageDialog[
    DynamicModule[
      {},
      Null,
      Initialization:>{
        Internal`WithLocalSettings[
          Null,
          Block[
            {
              $CurrentIDENotebook=nb
              },
            expr
            ],
          NotebookClose[EvaluationNotebook[]]
          ]
        },
      SynchronousInitialization -> False
      ],
    Visible->False,
    Evaluator->CurrentValue[nb, Evaluator]
    ];
PreemptiveQueued~SetAttributes~HoldRest


End[];



