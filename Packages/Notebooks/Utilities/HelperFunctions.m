(* ::Package:: *)

(* Autogenerated Package *)

WithNotebookPaused::usage="Pauses the notebook temporarily to execute code";
PreemptiveQueued::usage="Evaluates preemptive code in a queued fashion";


WithCurrentValueUpdating::usage="Executes with CurrentValue updating resumed";
WithoutCurrentValueUpdating::usage="Executes with CurrentValue updating paused";


(* ::Text:: *)
(*Consistent references to the current IDE notebook*)



$CurrentIDENotebook::usage="";
$CurrentIDE::usage="";


iCurrentValue::usage="Just reimplements CurrentValue for when it's needed";
SetCurrentValue::usage="";
SetCurrentValueDelayed::usage="";
WithIDEData::usage="Reroutes CurrentValue to the EasyIDE path";


Begin["`Private`"];


(* ::Subsection:: *)
(*CurrentValues*)



iCurrentValue[a___]:=
  With[{c=FrontEnd`CurrentValue[a]},
    Replace[
      MathLink`CallFrontEnd[
        FrontEnd`Value[c, FrontEnd`$TrackingEnabled]],
      c->$Failed
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*SetCurrentValue*)



SetCurrentValue//Clear
SetCurrentValue[nb_, k_, value_]:=
  With[{h=FrontEnd`$TrackingEnabled},
    MathLink`CallFrontEndHeld[
      FrontEnd`SetValue[
          FEPrivate`Set[
            FrontEnd`CurrentValue[nb, k], 
          value
            ],
          h
          ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*SetCurrentValueDelayed*)



SetCurrentValueDelayed//Clear
SetCurrentValueDelayed[nb_, k_, Hold[value_]]:=
  With[{h=FrontEnd`$TrackingEnabled},
    MathLink`CallFrontEndHeld[
      FrontEnd`SetValue[
        FEPrivate`SetDelayed[
          FrontEnd`CurrentValue[nb, k], 
          value
          ],
        h
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*WithIDEData*)



WithIDEData[nb_, expr_]:=
  Block[
    {
      CurrentValue,
      FrontEnd`Options
      },
    CurrentValue[a_, b_, c___]:=
      Block[{CurrentValue=iCurrentValue},
        IDEData[a, Flatten@{"Options", b}, c]
        ];
    CurrentValue/:
      (CurrentValue[a_, b_, c___] = v_):=
        Block[{CurrentValue=iCurrentValue},
          IDEData[a, Flatten@{"Options", b}] = v
          ];
    CurrentValue/:
      (CurrentValue[a_, b_, c___] := v_):=
        Block[{CurrentValue=iCurrentValue},
          IDEData[a, Flatten@{"Options", b}] := v
          ];
    FrontEnd`Options[n_]:=
      Block[
        {
          CurrentValue=
            FrontEnd`Value[FrontEnd`CurrentValue[##], FrontEnd`$TrackingEnabled]&
          },
        IDEData[n, "Options"]
        ];
    Internal`InheritedBlock[{NotebookGet},
      Unprotect[NotebookGet];
      NotebookGet[nb]:=
        Block[
          {
            NotebookGet=MathLink`CallFrontEnd[FrontEnd`NotebookGet[nb]]&,
            CurrentValue=iCurrentValue
            },
          GetNotebookExpression[nb]
          ];
      expr
      ]
    ];
WithIDEData~SetAttributes~HoldRest;


(* ::Subsection:: *)
(*IDE Refs*)



$CurrentIDENotebook := EvaluationNotebook[];
$CurrentIDE := IDENotebookObject[$CurrentIDENotebook];


(* ::Subsection:: *)
(*Helpers*)



(* ::Subsubsection::Closed:: *)
(*WithPausedNotebook*)



(* ::Text:: *)
(*
	Helper function to suspend the screen while updating the nb
*)



WithNotebookPaused[nb_NotebookObject, expr_]:=
  Block[
  {
    paused = If[TrueQ@paused, True, False],
    FrontEnd`$TrackingEnabled = False,
    setDataCalls 
      (* 
	            Should I catch all of the ideSetNbData calls...? 
	            I could batch them all up at once and maybe decrease the amount of processing time...
	            *)
    },
    If[paused,
      expr,
      Internal`WithLocalSettings[
        FrontEndExecute@
          {
            FrontEnd`NotebookSuspendScreenUpdates[nb],
            FrontEnd`SetOptions[nb, DynamicUpdating->False]
            },
        paused = True;
        expr,
        FrontEndExecute@
          {
            FrontEnd`SetOptions[nb, DynamicUpdating->Automatic],
            FrontEnd`NotebookResumeScreenUpdates[nb]
            }
        ]
      ]
    ];
WithNotebookPaused~SetAttributes~HoldRest


(* ::Subsubsection::Closed:: *)
(*WithCurrentValueUpdating*)



WithCurrentValueUpdating[expr_]:=
  Block[
    {
      FrontEnd`$TrackingEnabled = True
      },
    expr
    ];
WithCurrentValueUpdating~SetAttributes~HoldRest


(* ::Subsubsection::Closed:: *)
(*WithoutCurrentValueUpdating*)



(* ::Text:: *)
(*
	Helper function to suspend the screen while updating the nb
*)



WithoutCurrentValueUpdating//Clear
WithoutCurrentValueUpdating[expr_]:=
  Block[
    {
      FrontEnd`$TrackingEnabled = False
      },
    expr
    ];
WithoutCurrentValueUpdating~SetAttributes~HoldRest


(* ::Subsubsection::Closed:: *)
(*IDEPreemptive*)



PreemptiveQueued[nb_, expr_]:=
  MessageDialog[
    DynamicModule[
      {},
      Null,
      Initialization:>{
        Internal`WithLocalSettings[
          Null,
          Block[
            {
              $CurrentIDENotebook=nb
              },
            expr
            ],
          NotebookClose[EvaluationNotebook[]]
          ]
        },
      SynchronousInitialization -> False
      ],
    Visible->False,
    Evaluator->CurrentValue[nb, Evaluator]
    ];
PreemptiveQueued~SetAttributes~HoldRest


End[];



